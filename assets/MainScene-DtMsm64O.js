import{U as u,A as x,G as D,P as k,B as O,a as $,D as v,R as g,b as E,S as G,c as M,W as N}from"./index-ByMiue4U.js";import{g as z}from"./phaser-DFK5Ua9d.js";class I{constructor(e,t,i){this.scene=e,this.world=t,this.logger=i,this.createAnimation(),this.gridCursor=this.scene.add.sprite(0,0,"grid-cursor").setOrigin(0).setDepth(u.DEPTH.CURSOR).setVisible(!1),this.world.add(this.gridCursor),this.gridCursor.play(x.GRID_CURSOR.key)}gridCursor;createAnimation(){this.scene.anims.exists(x.GRID_CURSOR.key)||(this.scene.anims.create(x.GRID_CURSOR),this.logger.debug("Created grid cursor animation"))}update(e,t){const i=this.world.worldToGrid(e,t);if(!i){this.gridCursor.setVisible(!1);return}const s=this.world.gridToLocalCorner(i);this.gridCursor.setPosition(s.x,s.y).setVisible(!0)}hide(){this.gridCursor.setVisible(!1)}destroy(){this.gridCursor.destroy(),this.logger.debug("CursorRenderer destroyed")}}class L{constructor(e,t,i,s){this.scene=e,this.config=t,this.world=i,this.logger=s,this.renderQueueBorder()}spritePool=[];activeSprites=[];renderQueueBorder(){const{cellSize:e}=this.config.grid,t=this.config.queue.maxSize,i=e/2,s=1,r=t,a=(l,c,p)=>{const f=this.world.queueToLocalCorner({x:l,y:c}),m=this.scene.add.image(f.x+i,f.y+i,"queue-side").setOrigin(.5).setAngle(p).setDepth(98);this.world.add(m)},n=(l,c,p)=>{const f=this.world.queueToLocalCorner({x:l,y:c}),m=this.scene.add.image(f.x+i,f.y+i,"queue-corner").setOrigin(.5).setAngle(p).setDepth(99);this.world.add(m)};a(0,-1,0),a(0,r,180);for(let l=0;l<r;l++)a(-1,l,-90),a(s,l,90);n(-1,-1,0),n(s,-1,90),n(-1,r,-90),n(s,r,180);const o=this.world.queueToLocalCorner({x:0,y:0}),h=this.scene.add.image(o.x,o.y,"queue-selected").setOrigin(0).setDepth(97);this.world.add(h),this.logger.debug(`Queue border rendered: ${s}x${r} cells`)}render(e){this.activeSprites.forEach(s=>{s.setVisible(!1),this.spritePool.push(s)}),this.activeSprites=[];const i=this.config.grid.cellSize/2;e.contents.forEach((s,r)=>{const a=this.getOrCreateSprite(),n=this.world.queueToLocalCorner({x:0,y:r});a.setPosition(n.x+i,n.y+i).setTexture(s.assetKey).setRotation(Phaser.Math.DegToRad(s.direction.angle)).setVisible(!0),this.activeSprites.push(a)}),this.logger.debug(`Rendered queue (${e.contents.length} pipes)`)}getOrCreateSprite(){if(this.spritePool.length>0){const t=this.spritePool.pop();return t.parentContainer||this.world.add(t),t}const e=this.scene.add.image(0,0,"placeholder").setOrigin(.5).setDepth(100);return this.world.add(e),e}destroy(){this.activeSprites.forEach(e=>e.destroy()),this.spritePool.forEach(e=>e.destroy()),this.activeSprites=[],this.spritePool.length=0}}class q{constructor(e,t,i,s){this.scene=e,this.config=t,this.world=i,this.logger=s}renderBackground(e){const{width:t,height:i,cellSize:s}=this.config.grid,r=s/2,a=(o,h,l)=>{const c=this.world.gridToLocalCorner({x:o,y:h}),p=this.scene.add.image(c.x+r,c.y+r,"grid-border-side").setOrigin(.5).setAngle(l).setDepth(1);this.world.add(p)},n=(o,h,l)=>{const c=this.world.gridToLocalCorner({x:o,y:h}),p=this.scene.add.image(c.x+r,c.y+r,"grid-border-corner").setOrigin(.5).setAngle(l).setDepth(1);this.world.add(p)};for(let o=-1;o<=t;o++)a(o,-1,0),a(o,i,180);for(let o=0;o<i;o++)a(-1,o,-90),a(t,o,90);n(-1,-1,0),n(t,-1,90),n(-1,i,-90),n(t,i,180);for(let o=0;o<i;o++)for(let h=0;h<t;h++){const l=D.create(h,o,t,i),c=e.getCell(l),p=this.world.gridToLocalCorner(l),f=c.isBlocked?"grid-block":"grid-cell",m=this.scene.add.image(p.x,p.y,f).setOrigin(0).setDepth(2);this.world.add(m)}this.logger.debug(`Grid background rendered: ${t}x${i} cells with outer border`)}}class U{constructor(e,t){this.scene=e,this.world=t}pipeSprites=new Map;bombSprites=new Map;bombTimers=new Map;render(e){const t=this.world.gridToLocal(e.position),i=this.scene.add.image(t.x,t.y,e.assetKey).setOrigin(.5).setRotation(k.Math.DegToRad(e.direction.angle)).setDepth(u.DEPTH.PIPE);this.world.add(i),this.pipeSprites.set(e.position,i)}startBombAnimation(e,t,i){this.stopBombAnimation(e);const s=this.world.gridToLocal(e),r=this.scene.add.image(s.x,s.y,"bomb-idle").setOrigin(.5).setDepth(u.DEPTH.BOMB).setAlpha(1);this.world.add(r),this.bombSprites.set(e,r);const a=t/2,n=a/4,o=[],h=this.scene.time.delayedCall(a,()=>{let c=0;const p=["bomb-explosion-1","bomb-explosion-2","bomb-explosion-1","bomb-explosion-2"],f=this.scene.time.addEvent({delay:n,repeat:p.length-1,callback:()=>{r&&r.active&&(r.setTexture(p[c]),c++)}});o.push(f)});o.push(h);const l=this.scene.time.delayedCall(t,()=>{this.cleanupBombAnimation(e),i?.()});o.push(l),this.bombTimers.set(e,o)}stopBombAnimation(e){const t=this.bombTimers.get(e);t&&(t.forEach(i=>i.remove()),this.bombTimers.delete(e)),this.cleanupBombAnimation(e)}cleanupBombAnimation(e){const t=this.bombSprites.get(e);t&&(t.destroy(),this.bombSprites.delete(e));const i=this.bombTimers.get(e);i&&(i.forEach(s=>s.remove()),this.bombTimers.delete(e))}getSprite(e){return this.pipeSprites.get(e)}remove(e){this.stopBombAnimation(e);const t=this.pipeSprites.get(e);return t?(t.destroy(),this.pipeSprites.delete(e),!0):!1}clear(){this.bombTimers.forEach(e=>{e.forEach(t=>t.remove())}),this.bombTimers.clear(),this.bombSprites.forEach(e=>e.destroy()),this.bombSprites.clear(),this.pipeSprites.forEach(e=>e.destroy()),this.pipeSprites.clear()}destroy(){this.clear()}}var T={exports:{}},R;function W(){return R||(R=1,(function(b){var e=Object.prototype.hasOwnProperty,t="~";function i(){}Object.create&&(i.prototype=Object.create(null),new i().__proto__||(t=!1));function s(o,h,l){this.fn=o,this.context=h,this.once=l||!1}function r(o,h,l,c,p){if(typeof l!="function")throw new TypeError("The listener must be a function");var f=new s(l,c||o,p),m=t?t+h:h;return o._events[m]?o._events[m].fn?o._events[m]=[o._events[m],f]:o._events[m].push(f):(o._events[m]=f,o._eventsCount++),o}function a(o,h){--o._eventsCount===0?o._events=new i:delete o._events[h]}function n(){this._events=new i,this._eventsCount=0}n.prototype.eventNames=function(){var h=[],l,c;if(this._eventsCount===0)return h;for(c in l=this._events)e.call(l,c)&&h.push(t?c.slice(1):c);return Object.getOwnPropertySymbols?h.concat(Object.getOwnPropertySymbols(l)):h},n.prototype.listeners=function(h){var l=t?t+h:h,c=this._events[l];if(!c)return[];if(c.fn)return[c.fn];for(var p=0,f=c.length,m=new Array(f);p<f;p++)m[p]=c[p].fn;return m},n.prototype.listenerCount=function(h){var l=t?t+h:h,c=this._events[l];return c?c.fn?1:c.length:0},n.prototype.emit=function(h,l,c,p,f,m){var _=t?t+h:h;if(!this._events[_])return!1;var d=this._events[_],P=arguments.length,y,w;if(d.fn){switch(d.once&&this.removeListener(h,d.fn,void 0,!0),P){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,l),!0;case 3:return d.fn.call(d.context,l,c),!0;case 4:return d.fn.call(d.context,l,c,p),!0;case 5:return d.fn.call(d.context,l,c,p,f),!0;case 6:return d.fn.call(d.context,l,c,p,f,m),!0}for(w=1,y=new Array(P-1);w<P;w++)y[w-1]=arguments[w];d.fn.apply(d.context,y)}else{var F=d.length,S;for(w=0;w<F;w++)switch(d[w].once&&this.removeListener(h,d[w].fn,void 0,!0),P){case 1:d[w].fn.call(d[w].context);break;case 2:d[w].fn.call(d[w].context,l);break;case 3:d[w].fn.call(d[w].context,l,c);break;case 4:d[w].fn.call(d[w].context,l,c,p);break;default:if(!y)for(S=1,y=new Array(P-1);S<P;S++)y[S-1]=arguments[S];d[w].fn.apply(d[w].context,y)}}return!0},n.prototype.on=function(h,l,c){return r(this,h,l,c,!1)},n.prototype.once=function(h,l,c){return r(this,h,l,c,!0)},n.prototype.removeListener=function(h,l,c,p){var f=t?t+h:h;if(!this._events[f])return this;if(!l)return a(this,f),this;var m=this._events[f];if(m.fn)m.fn===l&&(!p||m.once)&&(!c||m.context===c)&&a(this,f);else{for(var _=0,d=[],P=m.length;_<P;_++)(m[_].fn!==l||p&&!m[_].once||c&&m[_].context!==c)&&d.push(m[_]);d.length?this._events[f]=d.length===1?d[0]:d:a(this,f)}return this},n.prototype.removeAllListeners=function(h){var l;return h?(l=t?t+h:h,this._events[l]&&a(this,l)):(this._events=new i,this._eventsCount=0),this},n.prototype.off=n.prototype.removeListener,n.prototype.addListener=n.prototype.on,n.prefixed=t,n.EventEmitter=n,b.exports=n})(T)),T.exports}var H=W();const C=z(H);class V extends C{constructor(e,t){super(),this.grid=e,this.logger=t}activeStates=[];visitedPorts=new Map;pathCache=new Map;initialize(e=0){const t=this.grid.tryGetStartPipe();if(!t){this.logger.warn("Cannot initialize flow: no start pipe");return}const i=t.openPorts[0];if(!i){this.logger.warn("Start pipe has no open ports");return}this.activeStates=[{pipe:t,entryDir:null,exitDir:i,progress:0,delayRemaining:e}],this.visitedPorts.clear(),this.pathCache.clear(),this.logger.info(`Flow initialized at ${t.position} with delay ${e}s`)}update(e,t){const i=[];for(const s of this.activeStates){if(s.delayRemaining>0){s.delayRemaining-=e,i.push(s);continue}s.entryDir&&!s.exitDir&&s.pipe.markPortUsed(s.entryDir);const r=s.progress;if(s.entryDir&&r==0&&(s.exitDir=this.selectExitDirection(s.pipe,s.entryDir),!s.exitDir)){this.logger.warn(`Flow stuck at ${s.pipe.position} - no valid exit`),this.emit("onFlowStuck",s.pipe);continue}if(s.progress+=t*e,s.entryDir&&r<50&&s.progress>=50&&this.markVisited(s.pipe,s.entryDir),s.progress<100){i.push(s);continue}if(r<100&&s.progress>=100&&(this.emit("onPipeFlowed",s.pipe),s.exitDir&&(this.markVisited(s.pipe,s.exitDir),s.pipe.markPortUsed(s.exitDir))),!s.exitDir)continue;const a=this.grid.getNeighborPipe(s.pipe.position,s.exitDir);if(!a){this.logger.debug(`No pipe available at ${s.pipe.position} exit ${s.exitDir.name}`),this.emit("onNoPathAvailable",s.pipe,s.exitDir);continue}if(a.isBombing){this.logger.debug(`Pipe at ${s.pipe.position} is being bombed`),this.emit("onNoPathAvailable",s.pipe,s.exitDir);continue}if(!a.accepts(s.exitDir.opposite)){this.logger.debug(`Pipe at ${a.position} doesn't accept connection from ${s.exitDir.name}`),this.emit("onNoPathAvailable",s.pipe,s.exitDir);continue}i.push({pipe:a,entryDir:s.exitDir.opposite,exitDir:null,progress:0,delayRemaining:0}),this.logger.debug(`Flow advanced from ${s.pipe.position} to ${a.position}`)}this.activeStates=i}getActiveState(){return this.activeStates[0]}getVisitedPortsSnapshot(){return Array.from(this.visitedPorts.entries()).map(([e,t])=>({pipe:e,dirs:Array.from(t)}))}clear(){this.activeStates=[],this.visitedPorts.clear(),this.logger.info("Flow network cleared")}selectExitDirection(e,t){const i=e.openPorts.filter(n=>n!==t);if(i.length===0)return null;const s=this.visitedPorts.get(e),r=i.filter(n=>!s?.has(n));if(r.length===1)return r[0];if(r.length===0)return null;const{direction:a}=this.calculateLongestPath(e,t,new Set);return a?(this.logger.debug(`Selected exit ${a.name} from ${e.position} (longest path)`),a):r[0]}markVisited(e,t){this.visitedPorts.has(e)||this.visitedPorts.set(e,new Set),this.visitedPorts.get(e).add(t)}calculateLongestPath(e,t,i){const s=this.createCacheKey(e,t),r=this.pathCache.get(s);if(r)return r;i.add(e);let a=null,n=-1;const o=e.openPorts.filter(l=>l!==t);for(const l of o){const c=this.grid.getNeighborPipe(e.position,l);if(!c||!c.accepts(l.opposite)||i.has(c))continue;const p=new Set(i),{length:f}=this.calculateLongestPath(c,l.opposite,p),m=1+f;m>n&&(n=m,a=l)}const h={direction:a,length:Math.max(0,n)};return this.pathCache.set(s,h),h}createCacheKey(e,t){return`${e.position.toString()},${t.name}`}invalidatePathCache(e){const t=[];for(const i of this.pathCache.keys())i.startsWith(e.position.toString())&&t.push(i);for(const i of t)this.pathCache.delete(i);t.length>0&&this.logger.debug(`Invalidated ${t.length} cache entries for ${e.position}`)}}class Y{constructor(e,t,i,s){this.scene=e,this.config=t,this.world=i,this.flowNetwork=s,this.graphics=this.scene.add.graphics({lineStyle:{width:3,color:65535}}),this.graphics.setDepth(50),this.world.add(this.graphics)}graphics;renderPreview(){this.graphics.clear(),this.renderCompletedPorts(),this.renderActiveFlow()}renderCompletedPorts(){const{cellSize:e}=this.config.grid,t=e/2,i=this.flowNetwork.getVisitedPortsSnapshot();for(const s of i){const r=this.world.gridToLocal(s.pipe.position);for(const a of s.dirs){const n=r.x+a.dx*t,o=r.y+a.dy*t;this.graphics.lineStyle(4,65535,1),this.graphics.lineBetween(r.x,r.y,n,o)}}}renderActiveFlow(){const e=this.flowNetwork.getActiveState();if(!e)return;const{pipe:t,entryDir:i,exitDir:s,progress:r}=e,{cellSize:a}=this.config.grid,n=a/2,o=this.world.gridToLocal(t.position),h=i?{x:o.x+i.dx*n,y:o.y+i.dy*n}:{x:o.x,y:o.y};s?this.renderFlowWithExit(h,o,s,n,r):this.renderFlowToCenter(h,o,r)}renderFlowWithExit(e,t,i,s,r){if(this.graphics.lineStyle(3,35071,1),r<=50){const a=r/50,n=e.x+(t.x-e.x)*a,o=e.y+(t.y-e.y)*a;this.graphics.lineBetween(e.x,e.y,n,o)}else{const a=(r-50)/50,n={x:t.x+i.dx*s,y:t.y+i.dy*s},o=t.x+(n.x-t.x)*a,h=t.y+(n.y-t.y)*a;this.graphics.lineBetween(t.x,t.y,o,h)}}renderFlowToCenter(e,t,i){const s=Math.min(1,i/100),r=e.x+(t.x-e.x)*s,a=e.y+(t.y-e.y)*s;this.graphics.lineStyle(3,35071,1),this.graphics.lineBetween(e.x,e.y,r,a)}clear(){this.graphics.clear()}}class Q{constructor(e,t,i,s,r){this.worldContainer=i,this.gridRenderer=new q(e,t,i,r),this.cursorRenderer=new I(e,i,r),this.pipeRenderer=new U(e,i),this.queueRenderer=new L(e,t,i,r),this.flowRenderer=new Y(e,t,i,s)}gridRenderer;cursorRenderer;pipeRenderer;queueRenderer;flowRenderer;renderGridBackground(e){this.gridRenderer.renderBackground(e)}addPipe(e){this.pipeRenderer.render(e)}removePipe(e){this.pipeRenderer.remove(e)}renderQueue(e){this.queueRenderer.render(e)}renderWaterFlow(){this.flowRenderer.renderPreview()}updateGridCursor(e,t){this.cursorRenderer.update(e,t)}hideGridCursor(){this.cursorRenderer.hide()}startBombAnimation(e,t,i){this.pipeRenderer.startBombAnimation(e,t,i)}worldToGrid(e,t){return this.worldContainer.worldToGrid(e,t)}gridToWorld(e){return this.worldContainer.gridToLocal(e)}destroy(){this.queueRenderer.destroy(),this.pipeRenderer.clear(),this.flowRenderer.clear()}}class X{constructor(e,t,i,s){this.scene=e,this.state=t,this.renderer=i,this.logger=s}enabled=!0;pointerDownHandler;pointerMoveHandler;pointerOutHandler;initialize(){this.pointerDownHandler=e=>{this.enabled&&this.handlePointerDown(e)},this.pointerMoveHandler=e=>{this.enabled&&this.handlePointerMove(e)},this.pointerOutHandler=()=>{this.enabled&&this.renderer.hideGridCursor()},this.scene.input.on("pointerdown",this.pointerDownHandler),this.scene.input.on("pointermove",this.pointerMoveHandler),this.scene.input.on("pointerout",this.pointerOutHandler),this.logger.debug("InputManager initialized")}enable(){this.enabled=!0,this.logger.debug("Input enabled")}disable(){this.enabled=!1,this.renderer.hideGridCursor(),this.logger.debug("Input disabled")}handlePointerDown(e){try{const{worldX:t,worldY:i}=this.getWorldCoordinates(e),s=this.renderer.worldToGrid(t,i);if(!s){this.logger.debug(`Pointer outside grid: world=(${t}, ${i})`);return}this.placePipeAtPosition(s)}catch(t){this.logger.error("Error during grid click",t)}}handlePointerMove(e){const{worldX:t,worldY:i}=this.getWorldCoordinates(e);this.renderer.updateGridCursor(t,i)}getWorldCoordinates(e){const i=this.scene.cameras.main.getWorldPoint(e.x,e.y);return{worldX:i.x,worldY:i.y}}placePipeAtPosition(e){const t=this.state.placeNextPipe(e);if(!t.success){this.logger.debug(`Failed to place pipe at ${e}: ${t.error}`);return}const i=t.value;this.renderer.addPipe(i),this.renderer.renderWaterFlow(),this.logger.debug(`Pipe placed at ${e}`)}destroy(){this.pointerDownHandler&&this.scene.input.off("pointerdown",this.pointerDownHandler),this.pointerMoveHandler&&this.scene.input.off("pointermove",this.pointerMoveHandler),this.pointerOutHandler&&this.scene.input.off("pointerout",this.pointerOutHandler),this.logger.debug("InputManager destroyed")}}class K{constructor(e,t,i){this.scene=e,this.state=t,this.logger=i,this.uiFixedContainer=this.scene.add.container(0,0).setScrollFactor(0),this.uiDynamicContainer=this.scene.add.container(0,0).setScrollFactor(0),this.buttonFactory=new O(e),this.scene.scale.on("resize",this.handleResize,this)}scoreText;gameOverPanel;overlay;backButton;uiFixedContainer;uiDynamicContainer;buttonFactory;currentScale=1;isActive=!0;createBaseUI(){this.createScoreDisplay(),this.createBackButton(),this.repositionUI(),this.logger.debug("Base UI created")}createScoreDisplay(){const e=this.state.scoreController.targetScore;this.scoreText=this.createText(u.LAYOUT.PADDING,u.LAYOUT.PADDING,`Pipes: 0/${e} | Score: 0`,{fontSize:u.TEXT.SCORE_SIZE,color:u.TEXT.COLOR_WHITE,padding:{x:12,y:8}}).setOrigin(0,0),this.uiFixedContainer.add(this.scoreText)}updateScoreDisplay(e,t){if(!this.scoreText)return;const i=this.state.scoreController.targetScore,s=this.state.scoreController.progressPercent.toFixed(0);this.scoreText.setText(`Pipes: ${t}/${i} (${s}%) | Score: ${e}`)}showGameOverPanel(e,t,i,s,r){const{width:a,height:n}=this.scene.scale;this.createOverlay(a,n),this.createPanel(e,0,u.LAYOUT.GAME_OVER_PANEL_OFFSET_Y);const o=this.createStatsText(0,u.LAYOUT.STATS_OFFSET_Y,t,i),h=this.createGameOverButtons(0,u.LAYOUT.BUTTON_ROW_OFFSET_Y,s,r);this.uiDynamicContainer.add([this.gameOverPanel,o,...h]),this.animateGameOverPanel(o,h),this.logger.info(`GameOverPanel displayed: ${e}`)}createOverlay(e,t){this.overlay=this.scene.add.rectangle(0,0,e,t,0,.7).setOrigin(0).setDepth(u.DEPTH.OVERLAY).setScrollFactor(0).setInteractive(),this.uiFixedContainer.add(this.overlay)}createPanel(e,t,i){this.gameOverPanel=this.scene.add.image(t,i,e).setDepth(u.DEPTH.PANEL).setScrollFactor(0).setScale(0)}createStatsText(e,t,i,s){return this.createText(e,t,`Final Score: ${i}
Pipes Connected: ${s}`,{fontSize:u.TEXT.STATS_SIZE,color:u.TEXT.COLOR_WHITE,stroke:u.TEXT.STROKE_COLOR,strokeThickness:u.TEXT.STROKE_THICKNESS,align:"center"}).setOrigin(.5).setAlpha(0)}createGameOverButtons(e,t,i,s){const r=u.LAYOUT.BUTTON_SPACING,a=this.buttonFactory.createPanelButton(e-r/2,t,"Play Again",i).setAlpha(0),n=this.buttonFactory.createPanelButton(e+r/2,t,"Main Menu",s).setAlpha(0);return[a,n]}animateGameOverPanel(e,t){this.scene.tweens.add({targets:this.gameOverPanel,scale:1,duration:u.ANIMATION.PANEL_SCALE_DURATION,ease:"Back.easeOut"}),this.scene.tweens.add({targets:[e,...t],alpha:1,duration:300,delay:u.ANIMATION.STATS_DELAY,ease:"Power2"})}createText(e,t,i,s={}){return this.scene.add.text(e,t,i,{fontFamily:u.TEXT.FONT_FAMILY,...s}).setDepth(u.DEPTH.UI_BASE)}createBackButton(){this.backButton=this.createText(0,0,"Back to Menu",{fontSize:u.TEXT.SCORE_SIZE,color:u.TEXT.COLOR_WHITE,padding:{x:12,y:6}}).setOrigin(1,0).setScrollFactor(0).setInteractive({useHandCursor:!0}),this.backButton.on("pointerdown",()=>{this.scene.events.emit("ui:backToMenu")}),this.uiFixedContainer.add(this.backButton)}handleResize(){this.isActive&&this.repositionUI()}repositionUI(){const{width:e,height:t}=this.scene.scale,i=e/2,s=t/2,r=e/u.RESPONSIVE.DESIGN_WIDTH,a=t/u.RESPONSIVE.DESIGN_HEIGHT,n=k.Math.Clamp(Math.min(r,a),u.RESPONSIVE.MIN_SCALE,u.RESPONSIVE.MAX_SCALE);n!==this.currentScale&&(this.currentScale=n,this.scene.tweens.add({targets:this.uiDynamicContainer,scale:n,duration:u.RESPONSIVE.SCALE_TWEEN_DURATION,ease:"Power2"})),this.uiDynamicContainer.setPosition(i,s),this.scoreText&&this.scoreText.setPosition(u.LAYOUT.PADDING,u.LAYOUT.PADDING),this.backButton&&this.backButton.setPosition(e-u.LAYOUT.PADDING,u.LAYOUT.PADDING),this.overlay&&this.isAlive(this.overlay)&&this.overlay.setSize(e,t)}isAlive(e){return!!(e&&e.scene)}destroy(){this.isActive=!1,this.scene.scale.off("resize",this.handleResize,this),this.uiFixedContainer.destroy(!0),this.uiDynamicContainer.destroy(!0),this.logger.debug("UIRenderer destroyed")}}class Z extends C{constructor(e,t){super(),this.config=e,this.logger=t}_score=0;_pipesFlowed=0;_gameEnded=!1;_flowedPipes=new Set;onPipeFlowed(e){if(this._gameEnded||e.shape.id==$.Start||this._flowedPipes.has(e))return;this._flowedPipes.add(e),this._pipesFlowed++;const t=this.config.pointsPerPipe??10;this._score+=t,this.emit("onScoreUpdated",this._score,this._pipesFlowed),this._pipesFlowed>=this.config.winFilledPipesCount&&this.triggerWin()}onFlowStuck(){this._gameEnded||(this.logger.warn(`Flow stuck at ${this._pipesFlowed}/${this.config.winFilledPipesCount} pipes`),this._pipesFlowed<this.config.winFilledPipesCount&&this.triggerLose("flow_stuck"))}onNoPathAvailable(){this._gameEnded||(this.logger.warn(`No path available at ${this._pipesFlowed}/${this.config.winFilledPipesCount} pipes`),this._pipesFlowed<this.config.winFilledPipesCount&&this.triggerLose("no_path"))}get score(){return this._score}get pipesFlowed(){return this._pipesFlowed}get targetScore(){return this.config.winFilledPipesCount}get gameEnded(){return this._gameEnded}get progressPercent(){return Math.min(100,this._pipesFlowed/this.config.winFilledPipesCount*100)}reset(){this._score=0,this._pipesFlowed=0,this._gameEnded=!1,this._flowedPipes.clear(),this.logger.info("Score controller reset")}triggerWin(){this._gameEnded||(this._gameEnded=!0,this.logger.info(`WIN! Final score: ${this._score} (${this._pipesFlowed} pipes)`),this.emit("onWin",this._score,this._pipesFlowed))}triggerLose(e){this._gameEnded||(this._gameEnded=!0,this.logger.info(`LOSE (${e})! Final score: ${this._score} (${this._pipesFlowed}/${this.config.winFilledPipesCount} pipes)`),this.emit("onLose",this._score,this._pipesFlowed,e))}}class B{constructor(e,t){this.shape=e,this.direction=t}get assetKey(){return`pipe-${this.shape.id}`}toString(){return`${this.shape.id}(${this.direction})`}}class J{constructor(e,t=!1){this.direction=e,this.used=t}}class A extends B{constructor(e,t,i){super(t,i),this.position=e,this.shape=t,this.direction=i;const s=this.rotateConnections(t.connections,i);this.ports=new Map(s.map(r=>[r,new J(r)])),this.bombState={isBombing:!1,startTime:0}}ports;bombState;get openPorts(){return Array.from(this.ports.values()).filter(e=>!e.used).map(e=>e.direction)}get usedPorts(){return Array.from(this.ports.values()).filter(e=>e.used).map(e=>e.direction)}get isBlocked(){return this.usedPorts.length>0||this.bombState.isBombing}accepts(e){return this.ports.has(e)}hasOpenPort(e){const t=this.ports.get(e);return!!t&&!t.used}markPortUsed(e){const t=this.ports.get(e);if(!t)throw new Error(`Cannot mark non-existent port ${e} as used on pipe at ${this.position}`);t.used=!0}startBombAnimation(e){this.bombState={isBombing:!0,startTime:e}}getBombProgress(e,t){if(!this.bombState.isBombing)return 0;const i=e-this.bombState.startTime;return Math.min(i/t,1)}get isBombing(){return this.bombState.isBombing}resetBombState(){this.bombState={isBombing:!1,startTime:0}}rotateConnections(e,t){const i=v.Right.angle,r=(t.angle-i+360)%360;return e.map(a=>{const n=(a.angle+r)%360;return v.fromAngle(n)})}toString(){const e=this.openPorts.map(t=>t.toString()).join(",");return`${this.assetKey}(${e}) at ${this.position}`}}class j{constructor(e,t,i,s,r={}){this.grid=e,this.queue=t,this.logger=i,this.config=s,this.events=r}bombingPipes=new Map;startBomb(e,t){if(this.bombingPipes.size>=this.config.maxBombs)return this.logger.debug(`Cannot start bomb: max limit of ${this.config.maxBombs} reached`),g.fail("max_bombs_reached");if(e===this.grid.tryGetStartPipe())return this.logger.debug("Cannot bomb the start pipe"),g.fail("cannot_bomb_start_pipe");if(e.isBlocked)return this.logger.debug(`Pipe at ${e.position} is blocked`),g.fail("pipe_blocked");const i=this.queue.peek();if(!i)return this.logger.warn("No pipe in queue for bomb replacement"),g.fail("queue_empty");e.startBombAnimation(t);const s={pipe:e,startTime:t,replacementPipe:i};this.bombingPipes.set(e,s);const r=this.config.bombTimerSeconds*1e3;return this.events.onBombStarted?.(e.position,r),this.logger.info(`Started bomb at ${e.position} (${this.bombingPipes.size}/${this.config.maxBombs} active)`),g.ok(void 0)}update(e){const t=[];for(const i of this.bombingPipes.values())e-i.startTime>=this.config.bombTimerSeconds&&t.push(i);for(const i of t)this.completeBomb(i)}cancelAll(){for(const e of this.bombingPipes.values())e.pipe.resetBombState();this.bombingPipes.clear(),this.logger.debug("All bombs cancelled")}completeBomb(e){const{pipe:t}=e,i=this.grid.getCell(t.position);this.bombingPipes.delete(t),t.resetBombState(),this.grid.removePipe(i),this.logger.debug(`Bomb exploded at ${i.position}`);const s=this.queue.dequeue();if(!s){this.logger.error("Queue empty during bomb completion - this should not happen");return}const r=new A(i.position,s.shape,s.direction),a=this.grid.setPipe(i,r);a.success?(this.logger.info(`Replaced bombed pipe at ${i.position} with ${s.shape.id} [${s.direction}]`),this.events.onBombCompleted?.(r)):this.logger.error(`Failed to place replacement pipe: ${a.error}`)}}class ee{weightedEntries;totalWeight;constructor(e){if(this.weightedEntries=Object.entries(e),this.totalWeight=this.weightedEntries.reduce((t,[,i])=>t+i,0),this.totalWeight<=0)throw new Error("Total pipe weights must be greater than 0")}generatePipe(){const e=this.selectRandomShape(),t=this.selectRandomDirection();return new B(e,t)}selectRandomShape(){let e=Math.random()*this.totalWeight;for(const[t,i]of this.weightedEntries)if(e-=i,e<=0)return E[t];return E[this.weightedEntries[0][0]]}selectRandomDirection(){const e=Math.floor(Math.random()*v.All.length);return v.All[e]}}class te extends C{constructor(e,t){super(),this.logger=e,this.config=t,this.generator=new ee(t.pipeWeights),this.fillQueue()}queue=[];generator;get contents(){return this.queue}dequeue(){this.queue.length===0&&(this.logger.warn("PipeQueue is empty — regenerating."),this.fillQueue());const e=this.queue.shift();return this.enqueueRandomPipe(),this.emit("onDequeued",e),this.emit("onUpdated",this.queue),this.logger.debug(`Dequeued pipe: ${e}`),e}peek(){return this.queue.length===0?(this.logger.warn("PipeQueue is empty — cannot peek."),null):this.queue[0]}reset(){this.queue.length=0,this.fillQueue(),this.logger.info("PipeQueue reset")}fillQueue(){for(;this.queue.length<this.config.maxSize;)this.enqueueRandomPipe();this.emit("onUpdated",this.queue),this.logger.info(`PipeQueue initialized with ${this.queue.length} items.`)}enqueueRandomPipe(){const e=this.generator.generatePipe();this.queue.push(e),this.logger.debug(`Enqueued new pipe: ${e}`)}}class ie{constructor(e){this.position=e}_pipe=null;_blocked=!1;get isBlocked(){return this._blocked}get pipe(){return this._pipe}get isEmpty(){return this._pipe===null}get hasPipe(){return this._pipe!==null}setPipe(e){if(this._blocked)throw new Error(`Cannot place pipe on blocked cell at ${this.position}`);if(this._pipe!==null)throw new Error(`Cell at ${this.position} already contains a pipe. Remove it first.`);if(!e.position.equals(this.position))throw new Error(`Pipe position ${e.position} does not match cell position ${this.position}`);this._pipe=e}clearPipe(){this._pipe=null}block(){this._blocked=!0,this._pipe=null}unblock(){this._blocked=!1}toString(){return`(${this.position} ${this._blocked?"[BLOCKED]":""}`}}class se{constructor(e,t){this.config=e,this.logger=t,this.width=e.width,this.height=e.height,this.cells=this.initializeGrid(),this.logger.info(`Grid created with dimensions ${this.dimensions}`)}cells;width;height;_startPipe=null;_initialized=!1;initialize(){if(this._initialized)return this.logger.warn("Grid already initialized"),g.fail("already_initialized");try{const e=this.createStartPipe();if(!e.success)return g.fail("initialization_failed");this._startPipe=e.value;const t=[this._startPipe.position,...this.getAllNeighbors(this._startPipe.position,!0).map(i=>i.position)];return this.blockRandomCells(this.config.blockedPercentage,t),this._initialized=!0,this.logger.info("Grid initialized successfully"),g.ok(void 0)}catch(e){return this.logger.error("Failed to initialize grid",e),g.fail("initialization_failed")}}get isInitialized(){return this._initialized}get startPipe(){if(!this._startPipe)throw new Error("Grid has not been initialized. Call initialize() first.");return this._startPipe}tryGetStartPipe(){return this._startPipe}getCell(e){if(!this.isValidPosition(e.x,e.y))throw new Error(`Position ${e} is out of bounds`);return this.cells[e.y][e.x]}tryGetCell(e){return this.isValidPosition(e.x,e.y)?this.cells[e.y][e.x]:null}getNeighbor(e,t){const i=e.move(t,this.width,this.height);return i?this.getCell(i):null}getValidNeighbor(e,t){const i=this.getNeighbor(e,t);return i&&!i.isBlocked?i:null}isValidPosition(e,t){return e>=0&&t>=0&&e<this.width&&t<this.height}setPipe(e,t){if(e.isBlocked)return g.fail("cell_blocked");if(!e.position.equals(t.position))return g.fail("position_mismatch");if(e.hasPipe)return g.fail("cell_occupied");try{return e.setPipe(t),this.logger.debug(`Placed ${t.shape.id} at ${e.position} facing ${t.direction}`),g.ok(void 0)}catch(i){return this.logger.error("Failed to set pipe",i),g.fail("cell_blocked")}}removePipe(e){if(e.isEmpty||e.isBlocked)return;const t=e.pipe;e.clearPipe(),this.logger.debug(`Removed ${t.shape.id} from ${e.position}`)}removePipeAt(e){const t=this.tryGetCell(e);t&&this.removePipe(t)}blockCell(e){if(!e.isEmpty){this.logger.warn(`Cannot block cell ${e.position} - contains pipe`);return}e.block(),this.logger.debug(`Cell ${e.position} marked as blocked`)}isConnectedToNetwork(e){return this.getConnectedNeighbors(e).length>0}getConnectedNeighbors(e){const t=[];for(const i of e.openPorts){const s=this.getValidNeighbor(e.position,i);if(!s?.hasPipe)continue;const r=s.pipe;r.hasOpenPort(i.opposite)&&t.push(r)}return t}getPipeAt(e){return this.tryGetCell(e)?.pipe??null}getNeighborPipe(e,t){return this.getNeighbor(e,t)?.pipe??null}forEachCell(e){for(let t=0;t<this.height;t++)for(let i=0;i<this.width;i++)e(this.cells[t][i])}findCells(e){const t=[];return this.forEachCell(i=>{e(i)&&t.push(i)}),t}getEmptyCells(){return this.findCells(e=>e.isEmpty)}getCellsWithPipes(){return this.findCells(e=>e.hasPipe)}clear(){this.forEachCell(e=>{e.pipe!==this._startPipe&&e.clearPipe()}),this.logger.info("Grid cleared (start pipe preserved)")}reset(){this._startPipe=null,this._initialized=!1,this.forEachCell(e=>{e.clearPipe(),e.unblock()}),this.logger.info("Grid reset to uninitialized state")}initializeGrid(){const e=[];for(let t=0;t<this.height;t++){const i=[];for(let s=0;s<this.width;s++){const r=D.createUnsafe(s,t);i.push(new ie(r))}e.push(i)}return e}createStartPipe(){const e=[];for(let h=0;h<this.height;h++)for(let l=0;l<this.width;l++){const c=this.cells[h][l];if(!c.isEmpty)continue;const p=v.All.filter(f=>this.getValidNeighbor(c.position,f)!==null);p.length>0&&e.push({cell:c,directions:p})}if(e.length===0)return this.logger.error("No valid start position found (empty cell with valid direction)"),g.fail("no_valid_start_position");const t=Math.floor(Math.random()*e.length),{cell:i,directions:s}=e[t],r=Math.floor(Math.random()*s.length),a=s[r],n=new A(i.position,E[$.Start],a);return this.setPipe(i,n).success?(this.logger.info(`Start pipe placed at ${i.position} facing ${n.direction}`),g.ok(n)):(this.logger.error("Failed to place start pipe despite having a valid cell/direction"),g.fail("no_valid_start_position"))}blockRandomCells(e,t=[]){if(e<=0)return;const i=this.width*this.height,s=Math.floor(e/100*i),r=this.getEmptyCells().filter(a=>!t.some(n=>n.equals(a.position)));for(let a=0;a<s&&r.length>0;a++){const n=Math.floor(Math.random()*r.length),[o]=r.splice(n,1);o.block()}this.logger.info(`Blocked ${s} cells (${e}%) for difficulty`)}getAllNeighbors(e,t=!0){const i=t?[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]]:[[0,-1],[-1,0],[1,0],[0,1]],s=[];for(const[r,a]of i){const n=e.x+r,o=e.y+a;this.isValidPosition(n,o)&&s.push(this.cells[o][n])}return s}get dimensions(){return{width:this.width,height:this.height}}getStats(){let e=0,t=0,i=0;return this.forEachCell(s=>{s.isBlocked?e++:s.hasPipe?t++:i++}),{totalCells:this.width*this.height,blockedCells:e,pipesPlaced:t,emptyCells:i,isInitialized:this._initialized}}}class re extends C{constructor(e,t){super(),this.config=e,this.logger=t,this._queue=new te(this.logger,this.config.queue),this._grid=new se(this.config.grid,this.logger),this._flowNetwork=new V(this._grid,t),this._score=new Z(this.config.score,this.logger),this._bombController=new j(this._grid,this._queue,this.logger,this.config.bomb,{onBombStarted:(i,s)=>this.emit("onBombStarted",i,s),onBombCompleted:i=>this.emit("onBombCompleted",i)}),this._flowNetwork.on("onPipeFlowed",i=>{this._score.onPipeFlowed(i)}),this._flowNetwork.on("onFlowStuck",()=>{this._score.onFlowStuck()}),this._flowNetwork.on("onNoPathAvailable",()=>{this._score.onNoPathAvailable()}),this._score.on("onScoreUpdated",(i,s)=>{this.emit("onScoreUpdated",i,s)}),this._score.on("onWin",(i,s)=>{this.logger.info(`GAME WON! Score: ${i}, Pipes: ${s}`),this.emit("onGameWon",i,s)}),this._score.on("onLose",(i,s,r)=>{this.logger.info(`GAME LOST (${r})! Score: ${i}, Pipes: ${s}`),this.emit("onGameLost",i,s,r)}),this.logger.debug("GameState constructed — grid and queue created.")}_grid;_queue;_score;_flowNetwork;_bombController;_initialized=!1;_currentTime=0;get grid(){return this._grid}get queue(){return this._queue}get scoreController(){return this._score}get bombController(){return this._bombController}get flowNetwork(){return this._flowNetwork}start(){if(this._initialized)return this.logger.warn("GameState already initialized"),g.fail("already_initialized");try{return this._grid.initialize().success?(this._flowNetwork.initialize(this.config.flow.startDelaySeconds),this._initialized=!0,this.emit("onInitialized",this._grid),this.logger.info(`GameState started successfully (${this.config.difficulty} difficulty)`),g.ok(void 0)):(this.logger.error("Failed to initialize grid"),g.fail("grid_initialization_failed"))}catch(e){return this.logger.error("Failed to start GameState",e),g.fail("grid_initialization_failed")}}update(e){this._score.gameEnded||(this._currentTime+=e,this._bombController.update(this._currentTime),this._flowNetwork.update(e,this.config.flow.pipeFlowSpeed))}stop(){return this._initialized?(this._bombController.cancelAll(),this._flowNetwork.clear(),this.emit("onStopped"),this._initialized=!1,this._currentTime=0,this.logger.info("GameState stopped"),g.ok(void 0)):(this.logger.warn("GameState not initialized — nothing to stop"),g.fail("not_initialized"))}reset(){this._bombController.cancelAll(),this._flowNetwork.clear(),this._score.reset(),this._queue.reset(),this._grid.reset(),this._initialized=!1,this._currentTime=0,this.logger.info("GameState reset")}destroy(){this.stop(),this._flowNetwork.removeAllListeners(),this._score.removeAllListeners(),this.removeAllListeners(),this.logger.info("GameState destroyed")}placeNextPipe(e){if(!this._initialized)return this.logger.warn("Cannot place pipe — game not initialized"),g.fail("game_not_initialized");if(this._score.gameEnded)return this.logger.warn("Cannot place pipe — game has ended"),g.fail("game_not_initialized");const t=this._grid.tryGetCell(e);if(!t)return this.logger.debug(`Invalid position: ${e}`),g.fail("invalid_position");if(t.isBlocked)return this.logger.debug(`Cannot place pipe — cell ${e} is blocked`),g.fail("cell_blocked");if(t.hasPipe){const i=t.pipe;return this._bombController.startBomb(i,this._currentTime).success?g.fail("bomb_started"):g.fail("cell_occupied")}try{const i=this._queue.dequeue(),s=new A(t.position,i.shape,i.direction),r=this._grid.setPipe(t,s);return r.success?(this.logger.info(`Placed ${i.shape.id} at ${t.position} [${i.direction}]`),this._flowNetwork.invalidatePathCache(s),g.ok(s)):(this.logger.error(`Failed to set pipe: ${r.error}`),g.fail("cell_blocked"))}catch(i){return this.logger.error("Failed to place next pipe",i),g.fail("cell_blocked")}}}class ae extends k.Scene{config;logger;state;worldContainer;assetRenderer;inputManager;uiRenderer;transitionManager;animationManager;constructor(){super({key:"MainScene"})}init(e){if(!e?.config||!e?.logger)throw new Error("MainScene requires config and logger from MenuScene");this.config=e.config,this.logger=e.logger,this.transitionManager=new G(this),this.animationManager=new M(this,this.logger),this.state=new re(this.config,this.logger),this.logger.info(`MainScene initialized with difficulty: ${this.config.difficulty}`)}create(){this.transitionManager.fadeIn(),this.animationManager.createGameAnimations(),this.worldContainer=new N(this,this.config),this.assetRenderer=new Q(this,this.config,this.worldContainer,this.state.flowNetwork,this.logger),this.subscribeToGameEvents(),this.state.start(),this.renderInitialState(),this.inputManager=new X(this,this.state,this.assetRenderer,this.logger),this.inputManager.initialize(),this.uiRenderer=new K(this,this.state,this.logger),this.uiRenderer.createBaseUI(),this.events.on("ui:backToMenu",()=>this.returnToMenu())}update(e,t){const i=t/1e3;this.state.update(i),this.assetRenderer.renderWaterFlow()}renderInitialState(){this.assetRenderer.renderGridBackground(this.state.grid);const e=this.state.queue;e.on("onUpdated",()=>this.assetRenderer.renderQueue(e)),this.assetRenderer.renderQueue(e)}subscribeToGameEvents(){this.state.once("onInitialized",e=>{const t=e.startPipe;this.assetRenderer.addPipe(t)}),this.state.on("onBombStarted",(e,t)=>{this.assetRenderer.startBombAnimation(e,t,()=>{this.logger.debug(`Bomb animation completed at ${e}`)})}),this.state.on("onBombCompleted",e=>{this.assetRenderer.removePipe(e.position),this.assetRenderer.addPipe(e)}),this.state.on("onScoreUpdated",(e,t)=>{this.uiRenderer.updateScoreDisplay(e,t)}),this.state.on("onGameWon",(e,t)=>{this.handleGameEnd("winner-panel",e,t)}),this.state.on("onGameLost",(e,t)=>{this.handleGameEnd("loser-panel",e,t)})}handleGameEnd(e,t,i){this.inputManager.disable(),this.uiRenderer.showGameOverPanel(e,t,i,()=>this.restartGame(),()=>this.returnToMenu())}async restartGame(){await this.transitionManager.restart({config:this.config,logger:this.logger})}async returnToMenu(){this.state.stop(),await this.transitionManager.transitionTo("MenuScene")}shutdown(){this.logger.debug("MainScene shutting down"),this.events.off("ui:backToMenu"),this.state&&(this.state.stop(),this.state.removeAllListeners()),this.inputManager&&this.inputManager.destroy(),this.uiRenderer&&this.uiRenderer.destroy(),this.assetRenderer&&this.assetRenderer.destroy(),this.worldContainer&&this.worldContainer.destroy(),this.logger.debug("MainScene shutdown complete")}}export{ae as MainScene};
